Out of the box webpack only knows to import only two kinds of files JavaScript and JSON files

So we have to teach webpack to import css files

Here loader is a type of libraries that helps webpack to import different kinds of files

NOTE -> check the order of loaders it goes from right to left
  use: ["style-loader", "css-loader", "less-loader"],


----------------------------------------------------
1. CSS files (npm i -D css-loader style-loader)

css-loader => knows how to read CSS files from disk 
style-loader => knows how to inject the css right into the document object modal


need to import multiple loaders in the rules section
`````````````````````````````
module: {
    rules: [
      
    ]
  }
``````````````````````````````

in this it contains series of object, each for different kinds of files
each object contains atleast 2 properties a) test -> regular exp to match the files b) either type or use-> [...specify the loaders]
`````````````````````````````
module: {
    rules: [
        {
            test: /\.css$/,
            use: ["style-loader", "css-loader"],
        },
    ],
  }
``````````````````````````````

we have to make each bundle small i.e. for js and for css so that can be achieved using different file names and plugins for the output generated by the webpack 

for example in webpack.prod.config.js we used hash file name for the output that is created in dist folder with 12 character "[name].[contenthash:12].js" with the help of MiniCssExtractPlugin helps us to create different file for css
`````````````````````````````````````
  output: {
    filename: "[name].[contenthash:12].js",
  },
  mode: "production",
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].[contenthash:12].styles.css",
    }),
  ],
```````````````````````````````````````````````

now observe in our index.html we have linked our css and script to 
    <link rel="stylesheet" href="./src/styles/index.css" />
    <script src="./dist/bundle.js"></script>
but when we build our prod code it will generate new hash coded file names every time change occurs so we need to update path everytime

so this index.html becomes dynamic

to achieve this we need plugin called html-webpack-plugin

1. create new file called template.html and put the content of index.html there and delete the index.html from root
2. to tell our webpack we have to use loader "html-loader" and use in the webpack.common.config.js 
- module: {
    rules: [
      {
        test: /\.html$/,
        use: [{ loader: "html-loader" }],
      },
    ],
  },
3. add this also to webpack.common.config.js to create dynamic index.html in our dist folder
- plugin: [
    new HtmlWebpackPlugin({
      filename: "index.html", // generated file
      template: "src/template.html", // template file that uses reference and create index.html accordingly
    }),
  ],

NOTE -> we are only generating seperate css file in our production mode
----------------------------------------------------

so currently when we make any changes it generates new files to keep our dist folder clean we can pass 
output: {
    path: path.resolve(__dirname, "../dist"),
    clean: true, // -> this is not working as expected in dev server
  },
in our webpack.common.config.js file to remove old bunldes and keep the new one only

now to get proper working code in dev server need new plugin called clean-wepback-plugin
add this in plugins [...,new CleanWebpackPlugin()]

----------------------------------------------------------
CSS module // filename.module.css

module: {
    rules: [
      {
        test: /\.css$/,
        exclude: /\.module\.css$/, // exclude module.css files
        use: ["style-loader", "css-loader"],
      },
      {
        test: /\.css$/,
        include: /\.module\.css$/, // only include module.css
        use: [
          "style-loader",
          {
            loader: "css-loader",
            options: {
              modules: {
                localIdentName: "[local]--[md4:hash:7]", // makes class name with [currentclassname]--hashedvalue
              },
            },
          },
        ],
      },
    ],

----------------------------------------------------------

right now css files are not minified (in prod mod only)
to minify our css add mini-css-extract-plugin

new property optimization
```````````````````````````````````````````````````````````
 optimization: {
    minimize: true,
    minimizer: [
      new CssMinimizerPlugin({
        minimizerOptions: {
          preset: [
            "default",
            {
              discardComments: { removeAll: true },
            },
          ],
        },
      }),
    ],
  },
```````````````````````````````````````````````````````````
here we have passed minimizer array which tell webpack to minimize only css files

by adding "..." tells to keep everything as before and now append the minifier to this 
```````````````````````````````````````````````````````````
 optimization: {
    minimize: true,
    minimizer: [
      `...`,
      new CssMinimizerPlugin({
        minimizerOptions: {
          preset: [
            "default",
            {
              discardComments: { removeAll: true },
            },
          ],
        },
      }),
    ],
  }, 
```````````````````````````````````````````````````````````

2. LESS files (npm i -D less less-loader) (at early ages, css was not able to use variables so less was introduced and with .less file we can use variables, mixins, etc)

in development we are using 
{
  test: /\.less$/,
  use: ["style-loader", "css-loader", "less-loader"],
},

while in production mode we are using 
use: [MiniCssExtractPlugin.loader, "css-loader" "less-loader"],


what is diff and why style-loader and css-loader here? can't less-loader handle everything?

- css-loader: The css-loader is responsible for loading and processing CSS files in webpack. It resolves @import and url() statements within CSS files and treats them as dependencies. It also handles transformations like CSS modules, allowing you to scope styles locally to a component. The css-loader transforms the CSS into JavaScript modules that can be understood by webpack.

- style-loader: The style-loader is a webpack loader that takes the JavaScript modules generated by the css-loader and injects them into the HTML document as <style> tags. This loader dynamically adds styles to the DOM during runtime, allowing them to take effect in the browser.

Now, regarding the difference and the use of these loaders in development and production:

- Development Mode: In development mode, the style-loader is used alongside the css-loader. The style-loader injects the styles into the DOM dynamically, which provides a faster development workflow. Changes to styles are immediately visible in the browser without requiring a full page reload. This approach helps with hot module replacement (HMR), where the styles can be updated in real-time as you make changes.

- Production Mode: In production mode, a different approach is taken to optimize the performance of the application. Instead of injecting styles dynamically using the style-loader, the MiniCssExtractPlugin.loader is used. This plugin extracts the CSS into separate external files, rather than injecting them as inline <style> tags. This separation of CSS from JavaScript can improve caching and load times for production builds. The extracted CSS files can be included in the HTML using standard <link> tags.

The less-loader is responsible for processing LESS files and converting them into CSS. It handles the transformation from LESS syntax to CSS syntax. It's important to note that the less-loader depends on the css-loader to handle the CSS processing, and the css-loader depends on the style-loader or MiniCssExtractPlugin.loader for injecting or extracting the styles.

---------------------------------------------------------

3. SCSS files (npm install sass-loader sass --save-dev)

{
  test: /\.scss$/,
  use: ["style-loader", "css-loader", "sass-loader"],
},

-> sass-loader => scss to css
-> css-loader => css to js
-> style-loader => create a style text inside our HTML page and put css inside those tags

---------------------------------------------------------------

4. PurgeCSS (npm i purgecss-webpack-plugin --save-dev)

Remove unused css from the project (eg tailwind, bootstrap unuse styles)

add this in webpack.prod.config.js
```````````````````````````````````````````````````````````````````
new PurgeCSSPlugin({
  paths: glob.sync(`${path.join(__dirname, "../src")}/**/*`, {
    nodir: true, // no directories only files
  }),
}),
`````````````````````````````````````````````````````````````````````

-------------------------------------------------------------------

5. CSS-in-JS (npm i -D jss jss-preset-default)

OR

(npm i -D @emotion/css)

we don't have to change anything in the webpack everything is managed using javascript and importing this packages in js files and with logics
